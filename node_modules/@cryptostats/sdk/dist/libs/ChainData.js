"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChainData = void 0;
class ChainData {
    constructor({ graph, date, cache, log }) {
        this.blockNumLoaders = {};
        this.promiseCache = {};
        this.graph = graph;
        this.date = date;
        this.cache = cache;
        this.log = log.getLogInterface();
        this.blockNumLoaders.ethereum = this.getBlockSubgraphQuery('blocklytics/ethereum-blocks');
        this.blockNumLoaders.kovan = this.getBlockSubgraphQuery('blocklytics/kovan-blocks');
        this.blockNumLoaders.goerli = this.getBlockSubgraphQuery('blocklytics/goerli-blocks');
        this.blockNumLoaders.rinkeby = this.getBlockSubgraphQuery('blocklytics/rinkeby-blocks');
        this.blockNumLoaders.xdai = this.getBlockSubgraphQuery('1hive/xdai-blocks');
        this.blockNumLoaders.fantom = this.getBlockSubgraphQuery('matthewlilley/fantom-blocks');
        this.blockNumLoaders.bsc = this.getBlockSubgraphQuery('generatefinance/bsc-blocks');
        this.blockNumLoaders.polygon = this.getBlockSubgraphQuery('elkfinance/matic-blocks');
        this.blockNumLoaders.avalanche = this.getBlockSubgraphQuery('dasconnor/avalanche-blocks');
        this.blockNumLoaders['arbitrum-one'] = this.getBlockSubgraphQuery('dodoex/arbitrum-one-blocks');
        this.blockNumLoaders.optimism = this.getBlockSubgraphQuery('dmihal/optimism-blocks');
    }
    getBlockNumber(date, chain = 'ethereum') {
        const key = `${chain}-${date.toString()}`;
        if (!this.promiseCache[key]) {
            this.promiseCache[key] = this.getBlockNumberInternal(date, chain);
        }
        return this.promiseCache[key];
    }
    async getBlockNumberInternal(date, chain) {
        const loader = this.blockNumLoaders[chain];
        if (!loader) {
            throw new Error(`Can't get block number for ${chain}`);
        }
        // We'll cache normal dates, but it doesn't make sense to cache arbitrary times
        if (typeof date !== 'string') {
            const block = await loader(date);
            return block;
        }
        const cachedValue = await this.cache.getValue(chain, 'block', date);
        if (cachedValue) {
            return cachedValue;
        }
        this.log.debug(`Cache miss for block number for ${chain} on ${date}`);
        const block = await loader(date);
        await this.cache.setValue(chain, 'block', date, block);
        return block;
    }
    getBlockSubgraphQuery(subgraph) {
        return (date) => this.blockSubgraphQuery(subgraph, date);
    }
    async blockSubgraphQuery(subgraph, date) {
        const time = this.dateToTime(date);
        const res = await this.graph.query(subgraph, `query blocks($timestampFrom: Int!, $timestampTo: Int!) {
        blocks(
          first: 1
          orderBy: timestamp
          orderDirection: asc
          where: { timestamp_gt: $timestampFrom, timestamp_lt: $timestampTo }
        ) {
          number
        }
      }`, {
            variables: {
                timestampFrom: time,
                timestampTo: time + 60 * 60, // 1 hour window
            },
        });
        return parseInt(res.blocks[0].number);
    }
    ;
    dateToTime(date) {
        if (typeof date === 'string') {
            return this.date.dateToTimestamp(date);
        }
        else if (typeof date === 'number') {
            const JAN_1_2000 = 946684800000;
            return date > JAN_1_2000 ? Math.floor(date / 1000) : date; // Convert ms to s
        }
        else {
            return Math.floor(date.getTime() / 1000);
        }
    }
}
exports.ChainData = ChainData;
