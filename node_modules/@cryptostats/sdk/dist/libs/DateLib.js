"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DateLib = void 0;
const addDays_1 = __importDefault(require("date-fns/addDays"));
const subDays_1 = __importDefault(require("date-fns/subDays"));
const DATE_REGEX = /^\d{4}-\d{2}-\d{2}$/;
const DATE_SPAN_REGEX = /^(-?\d+)(?: |-)days$/;
class DateLib {
    dateToTimestamp(date) {
        const _date = date.length ? new Date(date) : date;
        return Math.floor(_date.getTime() / 1000 / 86400) * 86400;
    }
    formatDate(date, connector = '-') {
        const pad = (num) => num.toString().padStart(2, '0');
        return [date.getUTCFullYear(), pad(date.getUTCMonth() + 1), pad(date.getUTCDate())].join(connector);
    }
    getYesterdayDate() {
        const date = subDays_1.default(new Date(), 1);
        return this.formatDate(date);
    }
    getNextDay(date) {
        return this.offsetDaysFormatted(date, 1);
    }
    getPreviousDay(date) {
        return this.offsetDaysFormatted(date, -1);
    }
    last7Days(date) {
        return [...new Array(7)]
            .map((_, num) => this.formatDate(subDays_1.default(date || new Date(), 7 - num)));
    }
    isBefore(date, comparrison) {
        if (!date) {
            return true;
        }
        const _comparrison = comparrison || this.formatDate(new Date());
        return new Date(date) < new Date(_comparrison);
    }
    getDateRange(dateStart, dateEnd) {
        let _dateStart = null;
        let _dateEnd = null;
        if (dateStart instanceof Date) {
            _dateStart = dateStart;
        }
        else if (DATE_REGEX.test(dateStart)) {
            _dateStart = new Date(dateStart);
        }
        if (dateEnd instanceof Date) {
            _dateEnd = dateEnd;
        }
        else if (DATE_REGEX.test(dateEnd)) {
            _dateEnd = new Date(dateEnd);
        }
        if (DATE_SPAN_REGEX.test(dateStart)) {
            if (!_dateEnd) {
                throw new Error(`End date (${dateEnd}) is invalid for relative date range (${dateStart})`);
            }
            const numDays = parseInt(DATE_SPAN_REGEX.exec(dateStart)[1]);
            _dateStart = subDays_1.default(_dateEnd, numDays);
        }
        if (DATE_SPAN_REGEX.test(dateEnd)) {
            if (!_dateStart) {
                throw new Error(`End date (${dateEnd}) is invalid for relative date range (${dateStart})`);
            }
            const numDays = parseInt(DATE_SPAN_REGEX.exec(dateEnd)[1]);
            _dateEnd = addDays_1.default(_dateStart, numDays);
        }
        if (!_dateStart) {
            throw new Error(`Invalid date ${dateStart}`);
        }
        if (!_dateEnd) {
            throw new Error(`Invalid date ${dateEnd}`);
        }
        if (_dateEnd < _dateStart) {
            let tmp = _dateStart;
            _dateStart = _dateEnd;
            _dateEnd = tmp;
        }
        const days = [];
        for (let date = _dateStart; date <= _dateEnd; date = addDays_1.default(date, 1)) {
            days.push(this.formatDate(date));
        }
        return days;
    }
    /**
     * @param {string} date - A YYYY-MM-DD formatted date
     * @param {number} numDays - The number of days to shift (may be negative)
     * @returns {string} An adjusted YYYY-MM-DD formatted date
     */
    offsetDaysFormatted(date, numDays) {
        return this.formatDate(addDays_1.default(new Date(date), numDays));
    }
    /**
     * Alias for offsetDaysFormatted
     * @param {string} date - A YYYY-MM-DD formatted date
     * @param {number} numDays - The number of days to shift (may be negative)
     * @returns {string} An adjusted YYYY-MM-DD formatted date
     */
    addDays(date, numDays) {
        return this.offsetDaysFormatted(date, numDays);
    }
}
exports.DateLib = DateLib;
