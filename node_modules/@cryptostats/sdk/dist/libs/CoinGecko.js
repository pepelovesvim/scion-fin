"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoinGecko = void 0;
class CoinGecko {
    constructor({ cache, http, log }) {
        this.cache = cache;
        this.http = http;
        this.log = log.getLogInterface();
    }
    async getCurrentPrice(name, currency = 'usd') {
        const response = await this.http.get(`https://api.coingecko.com/api/v3/simple/price?ids=${name}&vs_currencies=${currency}`);
        if (!response[name]) {
            throw new Error(`${name} is not a valid CoinGecko ID`);
        }
        return response[name][currency];
    }
    async getHistoricalPrice(name, date) {
        if (name == 'usd') {
            return 1;
        }
        const marketData = await this.getHistoricalMarketData(name, date);
        return marketData.price;
    }
    async getHistoricalMarketData(name, date) {
        let price = await this.cache.getValue(name, 'price', date);
        let marketCap = await this.cache.getValue(name, 'market-cap', date);
        if (!price || !marketCap) {
            const storedPrice = price;
            const storedMarketCap = marketCap;
            ({ price, marketCap } = await this.queryCoingecko(name, date));
            if (!storedPrice) {
                await this.cache.setValue(name, 'price', date, price);
            }
            if (!storedMarketCap) {
                await this.cache.setValue(name, 'market-cap', date, marketCap);
            }
        }
        return { price, marketCap };
    }
    async cacheMarketData(name, date, price, marketCap) {
        this.log.debug(`Optimisticly caching market data for ${name} on ${date}`);
        await Promise.all([
            this.cache.setValue(name, 'price', date, price),
            this.cache.setValue(name, 'market-cap', date, marketCap),
        ]);
    }
    async queryCoingecko(name, date, currency = 'usd') {
        this.log.debug(`Querying CoinGecko for ${name} on ${date}`);
        const reversedDate = date.split('-').reverse().join('-');
        const response = await this.http.get(`https://api.coingecko.com/api/v3/coins/${name}/history?date=${reversedDate}`);
        if (!response.market_data) {
            throw new Error(`Can't get price data for ${name}`);
        }
        return {
            price: response.market_data.current_price[currency],
            marketCap: response.market_data.market_cap[currency],
        };
    }
}
exports.CoinGecko = CoinGecko;
