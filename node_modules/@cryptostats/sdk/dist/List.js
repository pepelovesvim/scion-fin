"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Collection = exports.List = void 0;
const Adapter_1 = require("./Adapter");
const Module_1 = require("./Module");
const Metadata_1 = require("./Metadata");
class List {
    constructor(name, sdk) {
        this.adapters = [];
        this.bundleIds = [];
        this.adaptersById = {};
        this.bundlesById = {};
        this.modules = [];
        this.adaptersFetched = false;
        this.cacheKeyResolver = null;
        this.name = name;
        this.sdk = sdk;
    }
    addAdapter({ id, queries, metadata, bundle }) {
        var _a;
        if (this.adaptersById[id]) {
            throw new Error(`Adapter '${id}' already added`);
        }
        const adapter = new Adapter_1.Adapter(id, {
            metadata,
            cache: (_a = this.sdk) === null || _a === void 0 ? void 0 : _a.cache,
            bundle,
            cacheKeyResolver: this.cacheKeyResolver,
        });
        for (let name in queries) {
            adapter.addQuery(name, queries[name]);
        }
        this.adapters.push(adapter);
        this.adaptersById[id] = adapter;
        return adapter;
    }
    addBundle(id, metadata = {}) {
        if (this.bundleIds.indexOf(id) !== -1) {
            throw new Error(`Bundle ${id} already exists`);
        }
        this.bundleIds.push(id);
        this.bundlesById[id] = new Metadata_1.Metadata(metadata);
    }
    getAdapters() {
        return this.adapters;
    }
    getAdapter(id) {
        return this.adaptersById[id] || null;
    }
    getIDs() {
        return Object.keys(this.adaptersById);
    }
    async getBundle(id) {
        if (!this.bundlesById[id]) {
            throw new Error(`No bundle ${id}`);
        }
        const metadata = await this.bundlesById[id].getMetadata();
        return metadata;
    }
    getBundles() {
        return Promise.all(this.bundleIds.map(async (id) => ({
            id,
            metadata: await this.bundlesById[id].getMetadata(),
        })));
    }
    async executeQuery(type, ...params) {
        return Promise.all(this.adapters.map(async (adapter) => {
            const result = await adapter.query(type, ...params)
                .catch(error => ({ error }));
            const response = {
                id: adapter.id,
                bundle: adapter.bundle,
            };
            if (result === null || result === void 0 ? void 0 : result.error) {
                response.error = result.error.message || result.error;
                response.result = null;
            }
            else {
                response.result = result;
            }
            return response;
        }));
    }
    async executeQueryWithMetadata(type, ...params) {
        return Promise.all(this.adapters.map(async (adapter) => {
            const [result, metadata] = await Promise.all([
                adapter.query(type, ...params)
                    .catch(error => ({ error })),
                adapter.getMetadata(),
            ]);
            const response = {
                id: adapter.id,
                bundle: adapter.bundle,
                metadata,
            };
            return (result === null || result === void 0 ? void 0 : result.error)
                ? { ...response, error: result.error.message || result.error }
                : { ...response, result };
        }));
    }
    async executeQueriesWithMetadata(types, ...params) {
        return Promise.all(this.adapters.map(async (adapter) => {
            const [metadata, ...resultsList] = await Promise.all([
                adapter.getMetadata(),
                ...types.map(type => adapter.query(type, ...params)
                    .catch((error) => ({ error }))),
            ]);
            const results = {};
            const errors = {};
            types.forEach((type, index) => {
                const result = resultsList[index];
                if (result === null || result === void 0 ? void 0 : result.error) {
                    errors[type] = result.error.message || result.error;
                }
                else {
                    results[type] = result;
                }
            });
            return {
                id: adapter.id,
                results,
                errors,
                metadata,
                bundle: adapter.bundle,
            };
        }));
    }
    async fetchAdapters() {
        if (!this.sdk) {
            throw new Error('SDK not set');
        }
        if (this.adaptersFetched) {
            console.warn(`Adapters for ${this.name} already fetched, skipping`);
            return [];
        }
        const query = `query adapters($collection: String!){
      collectionAdapters(where: { collection: $collection }) {
        adapter {
          id
          code
        }
      }
    }`;
        const data = await this.sdk.graph.query(this.sdk.adapterListSubgraph, query, {
            variables: { collection: this.name },
        });
        const modules = await Promise.all(data.collectionAdapters.map((collectionAdapter) => collectionAdapter.adapter.code
            ? this.addAdaptersWithCode(collectionAdapter.adapter.code)
            : this.fetchAdapterFromIPFS(collectionAdapter.adapter.id)));
        this.modules = this.modules.concat(modules);
        this.adaptersFetched = true;
        return modules;
    }
    async fetchAdapterFromIPFS(cid) {
        if (!this.sdk) {
            throw new Error('SDK not set');
        }
        const code = await this.sdk.ipfs.getFile(cid);
        return this.addAdaptersWithCode(code);
    }
    addAdaptersWithCode(code) {
        if (!this.sdk) {
            throw new Error('SDK not set');
        }
        const context = this.sdk.getContext(this);
        const newModule = new Module_1.Module({
            code,
            context,
            executionTimeout: this.sdk.executionTimeout,
            vm: this.sdk.vm,
        });
        try {
            newModule.evaluate();
        }
        catch (e) {
            throw new Error(`Error evaluating module [${code.substring(0, 20)}]: ${e.message}`);
        }
        newModule.setup();
        this.modules.push(newModule);
        return newModule;
    }
    addAdaptersWithSetupFunction(setupFn) {
        if (!this.sdk) {
            throw new Error('SDK not set');
        }
        const context = this.sdk.getContext(this);
        const newModule = new Module_1.Module({
            setupFn,
            context,
            executionTimeout: this.sdk.executionTimeout,
            vm: this.sdk.vm,
        });
        newModule.setup();
        this.modules.push(newModule);
        return newModule;
    }
    setCacheKeyResolver(resolver) {
        this.cacheKeyResolver = resolver;
        for (const adapter of this.adapters) {
            adapter.setCacheKeyResolver(resolver);
        }
    }
    cleanupModules() {
        for (const module of this.modules) {
            module.cleanup();
        }
    }
}
exports.List = List;
exports.Collection = List;
