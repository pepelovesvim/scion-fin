"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseCryptoStatsSDK = void 0;
const MemoryCache_1 = require("./caches/MemoryCache");
const ChainData_1 = require("./libs/ChainData");
const CoinGecko_1 = require("./libs/CoinGecko");
const DateLib_1 = require("./libs/DateLib");
const Ethers_1 = require("./libs/Ethers");
const IPFS_1 = require("./libs/IPFS");
const Graph_1 = require("./libs/Graph");
const HTTP_1 = require("./libs/HTTP");
const Log_1 = require("./libs/Log");
const Plugins_1 = require("./libs/Plugins");
const Context_1 = require("./Context");
const Collection_1 = require("./Collection");
const Etherscan_1 = require("./libs/Etherscan");
class BaseCryptoStatsSDK {
    constructor({ ipfsGateway, cache, infuraKey, moralisKey, etherscanKey, mongoConnectionString, redisConnectionString, executionTimeout = 30, adapterListSubgraph = 'dmihal/cryptostats-adapter-registry-test', vm, onLog, } = {}) {
        this.collections = {};
        this.executionTimeout = executionTimeout;
        this.adapterListSubgraph = adapterListSubgraph;
        this.vm = vm || null;
        // Ensure the cache is set. This should be overwritten, but the compiler likes it :)
        this.cache = new MemoryCache_1.MemoryCache();
        if (cache) {
            this.cache = cache;
        }
        else {
            this.setupCache({ mongoConnectionString, redisConnectionString });
        }
        this.plugins = new Plugins_1.Plugins();
        this.date = new DateLib_1.DateLib();
        this.http = new HTTP_1.HTTP();
        this.ipfs = new IPFS_1.IPFS({ gateway: ipfsGateway });
        this.log = new Log_1.Log({ onLog });
        this.graph = new Graph_1.Graph({ http: this.http });
        this.chainData = new ChainData_1.ChainData({
            graph: this.graph,
            cache: this.cache,
            date: this.date,
            log: this.log,
        });
        this.ethers = new Ethers_1.Ethers({ chainData: this.chainData });
        this.coinGecko = new CoinGecko_1.CoinGecko({ http: this.http, cache: this.cache, log: this.log });
        this.etherscan = new Etherscan_1.Etherscan(etherscanKey ? { ethereum: etherscanKey } : {}, this.http);
        if (moralisKey) {
            const networks = ['mainnet', 'kovan', 'ropsten', 'goerli', 'rinkeby'];
            for (const network of networks) {
                const url = `https://speedy-nodes-nyc.moralis.io/${moralisKey}/eth/${network}/archive`;
                this.ethers.addProvider(network === 'mainnet' ? 'ethereum' : network, url, { archive: true });
            }
            this.ethers.addProvider('arbitrum-one', `https://speedy-nodes-nyc.moralis.io/${moralisKey}/arbitrum/mainnet`, { archive: true });
            this.ethers.addProvider('polygon', `https://speedy-nodes-nyc.moralis.io/${moralisKey}/polygon/mainnet/archive`, { archive: true });
            this.ethers.addProvider('bsc', `https://speedy-nodes-nyc.moralis.io/${moralisKey}/bsc/mainnet/archive`, { archive: true });
            this.ethers.addProvider('avalanche', `https://speedy-nodes-nyc.moralis.io/${moralisKey}/avalanche/mainnet`, { archive: true });
            this.ethers.addProvider('fantom', `https://speedy-nodes-nyc.moralis.io/${moralisKey}/fantom/mainnet`, { archive: true });
        }
        else if (infuraKey) {
            const networks = ['mainnet', 'kovan', 'ropsten', 'goerli', 'rinkeby'];
            for (const network of networks) {
                const url = `https://${network}.infura.io/v3/${infuraKey}`;
                this.ethers.addProvider(network === 'mainnet' ? 'ethereum' : network, url);
            }
        }
        this.ethers.addProvider('optimism', 'https://mainnet.optimism.io', { archive: true });
        this.ethers.addProvider('arbitrum-one', 'https://arb1.arbitrum.io/rpc');
    }
    getCollection(name) {
        if (!this.collections[name]) {
            this.collections[name] = new Collection_1.Collection(name, this);
        }
        return this.collections[name];
    }
    /**
     * @deprecated Use getCollection instead
     */
    getList(name) {
        return this.getCollection(name);
    }
    getContext(collection) {
        const context = new Context_1.Context({
            coinGecko: this.coinGecko,
            chainData: this.chainData,
            date: this.date,
            graph: this.graph,
            http: this.http,
            ipfs: this.ipfs,
            ethers: this.ethers,
            etherscan: this.etherscan,
            log: this.log,
            plugins: this.plugins,
            collection,
        });
        return context;
    }
}
exports.BaseCryptoStatsSDK = BaseCryptoStatsSDK;
