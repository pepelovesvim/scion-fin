"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Adapter = void 0;
const clean_1 = require("./utils/clean");
const Metadata_1 = require("./Metadata");
const timeout_1 = require("./utils/timeout");
class Adapter {
    constructor(id, { metadata, cache, bundle, cacheKeyResolver }) {
        this.queries = {};
        this.id = id;
        this.metadata = new Metadata_1.Metadata(metadata);
        this.cache = cache || null;
        this.bundle = bundle || null;
        this.cacheKeyResolver = cacheKeyResolver || null;
    }
    addQuery(type, query) {
        this.queries[type] = query;
    }
    async query(type, ...input) {
        var _a, _b;
        let _input = input;
        let allowMissingQuery = false;
        let refreshCache = false;
        let timeout = 60 * 1000; // One minute default timeout
        const lastElement = input.length > 0 ? input[input.length - 1] : null;
        if ((lastElement === null || lastElement === void 0 ? void 0 : lastElement.allowMissingQuery) || (lastElement === null || lastElement === void 0 ? void 0 : lastElement.refreshCache)) {
            if (lastElement.allowMissingQuery) {
                allowMissingQuery = true;
            }
            if (lastElement.refreshCache) {
                refreshCache = true;
            }
            if (lastElement.timeout) {
                timeout = lastElement.timeout;
            }
            _input = input.slice(0, -1);
        }
        if (allowMissingQuery && !this.queries[type]) {
            return null;
        }
        const cacheKey = this.cacheKeyResolver ? this.cacheKeyResolver(this.id, type, input) : null;
        const cachedValue = cacheKey && !refreshCache && await ((_a = this.cache) === null || _a === void 0 ? void 0 : _a.getValue(this.id, type, cacheKey));
        if (cachedValue) {
            return cachedValue;
        }
        else {
            const result = await timeout_1.timeoutPromise(this.executeQuery(type, ..._input), timeout);
            if (cacheKey) {
                await ((_b = this.cache) === null || _b === void 0 ? void 0 : _b.setValue(this.id, type, cacheKey, result));
            }
            return result;
        }
    }
    async executeQuery(type, ...params) {
        if (!this.queries[type]) {
            throw new Error(`Adapter ${this.id} does not support ${type} queries`);
        }
        try {
            const result = clean_1.clean(await this.queries[type](...params));
            return result;
        }
        catch (e) {
            throw new Error(`Error executing ${type} on ${this.id}: ${e.message}`);
        }
    }
    getRawMetadata() {
        return this.metadata.getRawMetadata();
    }
    async getMetadata() {
        return await this.metadata.getMetadata();
    }
    setCacheKeyResolver(newResolver) {
        this.cacheKeyResolver = newResolver;
    }
}
exports.Adapter = Adapter;
